<!-- Link to custom styles for the editor -->
<link rel="stylesheet" href="css/stylesText.css" />
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Text Editor</title>
</head>
<body>

  <!-- Top navigation bar with dropdown menus -->
  <div class="navbar">
    <div class="nav-item">File
      <div class="dropdown">
        <div onclick="newFile()">New</div>
        <div onclick="openFile()">Open</div>
        <div onclick="saveFile()">Save</div>
        <div onclick="downloadFile()">Download</div>
      </div>
    </div>

    <!-- Hidden file input for Open File -->
    <input type="file" id="fileInput" accept=".txt,.json" style="display:none">

    <div class="nav-item">Edit
      <div class="dropdown">
        <div onclick="document.execCommand('undo')">Undo</div>
        <div onclick="document.execCommand('redo')">Redo</div>
        <div onclick="document.execCommand('cut')">Cut</div>
        <div onclick="document.execCommand('copy')">Copy</div>
        <div onclick="document.execCommand('paste')">Paste</div>
      </div>
    </div>
    <div class="nav-item">View
      <div class="dropdown">
        <div onclick="zoomIn()">Zoom In</div>
        <div onclick="zoomOut()">Zoom Out</div>
        <div onclick="toggleFullScreen()">Full Screen</div>
      </div>
    </div>
    <div class="nav-item">Insert
      <div class="dropdown">
        <div onclick="addPicture()">Add Picture</div>
      </div>
    </div>
    <div class="nav-item">Format
      <div class="dropdown">
        <div onclick="setFormat('bold')">Bold</div>
        <div onclick="setFormat('italic')">Italic</div>
        <div onclick="setFormat('underline')">Underline</div>
        <div onclick="setFormat('foreColor', 'blue')">Blue</div>
        <div onclick="setFormat('foreColor', 'black')">Black</div>
        <div onclick="setFormat('fontSize', 4)">Large</div>
        <div onclick="setFormat('fontSize', 2)">Normal</div>
      </div>
    </div>
    <div class="nav-item">Help</div>
  </div>

  <!-- Toolbar buttons with formatting options -->
  <div class="toolbar">
    <button data-command="bold"><b>B</b></button>
    <button data-command="italic"><i>I</i></button>
    <button data-command="underline"><u>U</u></button>
    <button data-command="foreColor" data-value="blue">Blue</button>
    <button data-command="foreColor" data-value="black">Black</button>
    <button data-command="fontSize" data-value="4">Large</button>
    <button data-command="fontSize" data-value="2">Normal</button>
    <button onclick="exportFormattedText()">Export</button>
  </div>

<div >
  
   <!-- Title Input -->
  <input type="text" class="title-box" placeholder="Document Title" />
  
</div>

  <!-- Editable content area -->
  <div class="editor" id="editor" contenteditable="true"></div>

  <!-- Output area to show exported JSON format -->
  <h2>Exported Format</h2>
  <pre id="output"></pre>

  <script>
    // Apply formatting using execCommand
    function setFormat(command, value = null) {
      document.execCommand(command, false, value);
    }

    // Export editor content to styled JSON
    function exportFormattedText() {
      const editor = document.getElementById("editor");
      const output = document.getElementById("output");

      const lines = [];
      let currentLine = [];
      let lastStyle = null;

      // Extract text styles from a node
      function extractStyle(el) {
        const style = window.getComputedStyle(el);
        return {
          color: style.color,
          bold: style.fontWeight === "bold" || parseInt(style.fontWeight) >= 600,
          italic: style.fontStyle === "italic",
          underline: style.textDecoration.includes("underline"),
          fontSize: parseInt(style.fontSize)
        };
      }

      function stylesEqual(a, b) {
        return JSON.stringify(a) === JSON.stringify(b);
      }

      // Add text chunk to current line
      function pushChunk(text, style) {
        if (!text) return;
        if (lastStyle && stylesEqual(lastStyle, style)) {
          currentLine[currentLine.length - 1].text += text;
        } else {
          currentLine.push({ text, style });
          lastStyle = style;
        }
      }

      function flushLine() {
        lines.push(currentLine);
        currentLine = [];
        lastStyle = null;
      }

      // Walk all nodes in editor recursively
      function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text.trim() !== "" || text.includes(" ")) {
            const style = extractStyle(node.parentElement || editor);
            pushChunk(text, style);
            }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName;

            if (tag === "BR") {
            flushLine(); // New line
            } else {
            for (const child of node.childNodes) {
                walk(child);
            }

            if (tag === "DIV") {
                flushLine(); // Treat DIV as paragraph break
            }
            }
        }
        }


      for (const node of editor.childNodes) {
        walk(node, extractStyle(editor));
      }

      if (currentLine.length > 0) {
        lines.push(currentLine);
      }

      // visual representation of json style
      output.textContent = JSON.stringify(lines, null, 2);

      //Export as .json file
      const blob = new Blob([JSON.stringify(lines, null, 2)], { type: "application/json" });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");

      // Use title input if provided
      const title = document.querySelector(".title-box").value || "document";
      a.download = `${title}.json`;
      a.href = url;


       // remove old link if it exists
      const existing = document.getElementById("downloadJsonLink");
      if (existing) existing.remove();

      // Set visible text and ID with basic formatting
      a.textContent = `Download ${title}.json`;
      a.id = "downloadJsonLink";
      a.style.display = "inline-block";
      a.style.marginTop = "10px";

      // Append to the page near output
      output.parentNode.insertBefore(a, output.nextSibling);
   
    }

    // File options
    function newFile() {
      document.getElementById("editor").innerHTML = "";
      document.querySelector('.title-box').value = "";
    }

    function saveFile() {
      alert("Save not implemented yet.");
    }

    // can take plain text (txt) orstyled text (JSON)
    function openFile() {

        const fileInput = document.getElementById('fileInput');
        fileInput.click(); // triggers the hidden file dialog

      fileInput.onchange = () => {
        const file = fileInput.files[0];
        
        if (!file) return;

        // Extract filename without extension
        const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
        document.querySelector('.title-box').value = nameWithoutExt;

        const reader = new FileReader();

        reader.onload = (e) => {
         const content = e.target.result;
          
         if(file.name.endsWith(".json"))
         {
            try {
              
              const parsed = JSON.parse(content);
              loadStyledContent(parsed);

            } catch(err){
              alert("Failed to load JSON content.");
            }
         }
         else
         {
          //plain text
          document.getElementById("editor").innerText = content; 
         }
  
        };

        reader.readAsText(file);
      
      };
    }

    function loadStyledContent(lines) {
      const editor = document.getElementById("editor");
      editor.innerHTML = ""; // clear existing content

      lines.forEach(line => {
        const div = document.createElement("div");

        line.forEach(segment => {
          const span = document.createElement("span");
          span.textContent = segment.text;

          const style = segment.style;
          span.style.color = style.color || "black";
          span.style.fontWeight = style.bold ? "bold" : "normal";
          span.style.fontStyle = style.italic ? "italic" : "normal";
          span.style.textDecoration = style.underline ? "underline" : "none";
          span.style.fontSize = style.fontSize ? `${style.fontSize}px` : "16px";

          div.appendChild(span);
        });

        editor.appendChild(div);
      });
    }


    // Download editor content as plain text
    function downloadFile() {
      const text = document.getElementById("editor").innerText;
      const blob = new Blob([text], { type: "text/plain" });
      const link = document.createElement("a");
      link.download = "document.txt";
      link.href = window.URL.createObjectURL(blob);
      link.click();
    }

    // Zoom and full screen actions
    function zoomIn() {
      document.getElementById("editor").style.zoom = "1.2";
    }

    function zoomOut() {
      document.getElementById("editor").style.zoom = "1.0";
    }

    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    function addPicture() {
      alert("Add picture not implemented yet.");
    }

    // Toolbar button functionality
    document.querySelectorAll(".toolbar button").forEach(button => {
      button.addEventListener("click", () => {
        const command = button.dataset.command;
        const value = button.dataset.value || null;
        document.execCommand(command, false, value);

        // Highlight active formatting buttons
        if (["bold", "italic", "underline"].includes(command)) {
          button.classList.toggle("active");
        }
      });
    });

    // Keep toolbar buttons in sync with selection
    document.getElementById("editor").addEventListener("keyup", updateToolbarState);
    document.getElementById("editor").addEventListener("mouseup", updateToolbarState);

    function updateToolbarState() {
      const commands = ["bold", "italic", "underline"];
      commands.forEach(cmd => {
        const state = document.queryCommandState(cmd);
        document.querySelector(`button[data-command="${cmd}"]`)?.classList.toggle("active", state);
      });
    }
  </script>
</body>
</html>
