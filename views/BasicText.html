<!-- Link to custom styles for the editor -->
<link rel="stylesheet" href="css/stylesText.css" />
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Text Editor</title>
</head>
<body>

  <!-- Top navigation bar with dropdown menus -->
  <div class="navbar">
    <div class="nav-item">File
      <div class="dropdown">
        <div onclick="newFile()">New</div>
        <div onclick="openFile()">Open</div>
        <div onclick="saveFile()">Save</div>
        <div onclick="downloadFile()">Download</div>
      </div>
    </div>
    <div class="nav-item">Edit
      <div class="dropdown">
        <div onclick="document.execCommand('undo')">Undo</div>
        <div onclick="document.execCommand('redo')">Redo</div>
        <div onclick="document.execCommand('cut')">Cut</div>
        <div onclick="document.execCommand('copy')">Copy</div>
        <div onclick="document.execCommand('paste')">Paste</div>
      </div>
    </div>
    <div class="nav-item">View
      <div class="dropdown">
        <div onclick="zoomIn()">Zoom In</div>
        <div onclick="zoomOut()">Zoom Out</div>
        <div onclick="toggleFullScreen()">Full Screen</div>
      </div>
    </div>
    <div class="nav-item">Insert
      <div class="dropdown">
        <div onclick="addPicture()">Add Picture</div>
      </div>
    </div>
    <div class="nav-item">Format
      <div class="dropdown">
        <div onclick="setFormat('bold')">Bold</div>
        <div onclick="setFormat('italic')">Italic</div>
        <div onclick="setFormat('underline')">Underline</div>
        <div onclick="setFormat('foreColor', 'blue')">Blue</div>
        <div onclick="setFormat('foreColor', 'black')">Black</div>
        <div onclick="setFormat('fontSize', 4)">Large</div>
        <div onclick="setFormat('fontSize', 2)">Normal</div>
      </div>
    </div>
    <div class="nav-item">Help</div>
  </div>

  <!-- Toolbar buttons with formatting options -->
  <div class="toolbar">
    <button data-command="bold"><b>B</b></button>
    <button data-command="italic"><i>I</i></button>
    <button data-command="underline"><u>U</u></button>
    <button data-command="foreColor" data-value="blue">Blue</button>
    <button data-command="foreColor" data-value="black">Black</button>
    <button data-command="fontSize" data-value="4">Large</button>
    <button data-command="fontSize" data-value="2">Normal</button>
    <button onclick="exportFormattedText()">Export</button>
  </div>

  <!-- Editable content area -->
  <div class="editor" id="editor" contenteditable="true" placeholder="Start typing here..."></div>

  <!-- Output area to show exported JSON format -->
  <h2>Exported Format</h2>
  <pre id="output"></pre>

  <script>
    // Apply formatting using execCommand
    function setFormat(command, value = null) {
      document.execCommand(command, false, value);
    }

    // Export editor content to styled JSON
    function exportFormattedText() {
      const editor = document.getElementById("editor");
      const output = document.getElementById("output");

      const lines = [];
      let currentLine = [];
      let lastStyle = null;

      // Extract text styles from a node
      function extractStyle(el) {
        const style = window.getComputedStyle(el);
        return {
          color: style.color,
          bold: style.fontWeight === "bold" || parseInt(style.fontWeight) >= 600,
          italic: style.fontStyle === "italic",
          underline: style.textDecoration.includes("underline"),
          fontSize: parseInt(style.fontSize)
        };
      }

      function stylesEqual(a, b) {
        return JSON.stringify(a) === JSON.stringify(b);
      }

      // Add text chunk to current line
      function pushChunk(text, style) {
        if (!text) return;
        if (lastStyle && stylesEqual(lastStyle, style)) {
          currentLine[currentLine.length - 1].text += text;
        } else {
          currentLine.push({ text, style });
          lastStyle = style;
        }
      }

      function flushLine() {
        lines.push(currentLine);
        currentLine = [];
        lastStyle = null;
      }

      // Walk all nodes in editor recursively
      function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text.trim() !== "" || text.includes(" ")) {
            const style = extractStyle(node.parentElement || editor);
            pushChunk(text, style);
            }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName;

            if (tag === "BR") {
            flushLine(); // New line
            } else {
            for (const child of node.childNodes) {
                walk(child);
            }

            if (tag === "DIV") {
                flushLine(); // Treat DIV as paragraph break
            }
            }
        }
        }


      for (const node of editor.childNodes) {
        walk(node, extractStyle(editor));
      }

      if (currentLine.length > 0) {
        lines.push(currentLine);
      }

      output.textContent = JSON.stringify(lines, null, 2);
    }

    // File options
    function newFile() {
      document.getElementById("editor").innerHTML = "";
    }

    function saveFile() {
      alert("Save not implemented yet.");
    }

    function openFile() {
      alert("Open not implemented yet.");
    }

    // Download editor content as plain text
    function downloadFile() {
      const text = document.getElementById("editor").innerText;
      const blob = new Blob([text], { type: "text/plain" });
      const link = document.createElement("a");
      link.download = "document.txt";
      link.href = window.URL.createObjectURL(blob);
      link.click();
    }

    // Zoom and full screen actions
    function zoomIn() {
      document.getElementById("editor").style.zoom = "1.2";
    }

    function zoomOut() {
      document.getElementById("editor").style.zoom = "1.0";
    }

    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    function addPicture() {
      alert("Add picture not implemented yet.");
    }

    // Toolbar button functionality
    document.querySelectorAll(".toolbar button").forEach(button => {
      button.addEventListener("click", () => {
        const command = button.dataset.command;
        const value = button.dataset.value || null;
        document.execCommand(command, false, value);

        // Highlight active formatting buttons
        if (["bold", "italic", "underline"].includes(command)) {
          button.classList.toggle("active");
        }
      });
    });

    // Keep toolbar buttons in sync with selection
    document.getElementById("editor").addEventListener("keyup", updateToolbarState);
    document.getElementById("editor").addEventListener("mouseup", updateToolbarState);

    function updateToolbarState() {
      const commands = ["bold", "italic", "underline"];
      commands.forEach(cmd => {
        const state = document.queryCommandState(cmd);
        document.querySelector(`button[data-command="${cmd}"]`)?.classList.toggle("active", state);
      });
    }
  </script>
</body>
</html>
